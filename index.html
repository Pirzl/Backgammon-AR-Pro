
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>B-GAMMON AR ULTIMATE</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,400;0,700;0,900;1,900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.2/peerjs.min.js"></script>
    
    <!-- Mediapipe para Hand Tracking (AR) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body, html, #root {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background: #000; color: #fff; font-family: 'Inter', sans-serif;
            overflow: hidden; touch-action: none;
        }
        video { 
            position: absolute; inset: 0; width: 100%; height: 100%; 
            object-fit: cover; z-index: 0; transform: scaleX(-1);
        }
        canvas { 
            position: absolute; inset: 0; width: 100%; height: 100%; 
            z-index: 10; pointer-events: auto;
        }
        .ui-layer { position: absolute; inset: 0; z-index: 20; pointer-events: none; }
        .ui-layer * { pointer-events: auto; }
        
        /* Menu Lateral (Foto) */
        .side-menu {
            position: absolute; left: 0; top: 0; bottom: 0; width: 320px;
            background: linear-gradient(90deg, rgba(15,15,15,0.98) 0%, rgba(15,15,15,0.8) 100%);
            border-right: 1px solid rgba(255,255,255,0.1);
            padding: 40px 24px; transform: translateX(-100%); transition: transform 0.4s ease;
            display: flex; flex-direction: column;
        }
        .side-menu.open { transform: translateX(0); }
        
        .btn-menu { width: 100%; padding: 18px; border-radius: 16px; font-weight: 900; text-transform: uppercase; font-size: 13px; margin-bottom: 12px; transition: all 0.2s; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05); }
        .btn-menu:active { transform: scale(0.98); }
        .btn-menu.primary { background: #fff; color: #000; }
        .btn-menu.accent { color: #fbbf24; border-color: #fbbf24; }
        
        input[type="range"] { appearance: none; background: rgba(255,255,255,0.1); height: 3px; border-radius: 2px; width: 100%; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: #fbbf24; border-radius: 50%; box-shadow: 0 0 10px #fbbf24; cursor: pointer; }

        .title-main { font-style: italic; font-weight: 900; line-height: 0.8; letter-spacing: -0.05em; text-transform: uppercase; font-size: 8rem; }
        
        @keyframes glow {
            0% { box-shadow: 0 0 5px #fbbf24; }
            50% { box-shadow: 0 0 25px #fbbf24; }
            100% { box-shadow: 0 0 5px #fbbf24; }
        }
        .active-glow { animation: glow 2s infinite; border: 2px solid #fbbf24; }
    </style>

    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.0.0",
    "react-dom": "https://esm.sh/react-dom@19.0.0",
    "react-dom/client": "https://esm.sh/react-dom@19.0.0/client",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <script type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';

        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 800;
        
        const COLORS = {
            pointLight: '#A88B66',
            pointDark: '#2C1D14',
            whiteChecker: ['#FFFFFF', '#CCCCCC'],
            redChecker: ['#FF3B30', '#AA1100'],
            gold: '#fbbf24'
        };

        const getInitialState = () => {
            const p = Array(24).fill(null).map(() => ({ checkers: [] }));
            const add = (idx, n, col) => { for (let i = 0; i < n; i++) p[idx].checkers.push(col); };
            add(0, 2, 'red'); add(11, 5, 'red'); add(16, 3, 'red'); add(18, 5, 'red');
            add(23, 2, 'white'); add(12, 5, 'white'); add(7, 3, 'white'); add(5, 5, 'white');
            return {
                points: p, bar: { white: 0, red: 0 }, off: { white: 0, red: 0 },
                turn: 'white', dice: [], movesLeft: [], winner: null,
                gameMode: 'LOCAL', userColor: 'white', roomID: ''
            };
        };

        const App = () => {
            const [view, setView] = useState('HOME');
            const [state, setState] = useState(getInitialState());
            const [camOpacity, setCamOpacity] = useState(0.4);
            const [boardOpacity, setBoardOpacity] = useState(0.9);
            const [isMenuOpen, setIsMenuOpen] = useState(false);
            const [selectedPoint, setSelectedPoint] = useState(null);
            const [handPos, setHandPos] = useState(null);

            const canvasRef = useRef(null);
            const videoRef = useRef(null);
            const peerRef = useRef(null);
            const connRef = useRef(null);
            const handsRef = useRef(null);

            // --- LÓGICA DE DIBUJO ---
            const getPointCoords = (i) => {
                const isTop = i >= 12;
                const col = isTop ? i - 12 : 11 - i;
                const xBase = 110 + col * 80;
                const x = col >= 6 ? xBase + 60 : xBase;
                return { x, yBase: isTop ? 50 : 750, yTip: isTop ? 380 : 420, isTop };
            };

            const drawChecker = (ctx, x, y, color, isSelected = false) => {
                const colors = color === 'white' ? COLORS.whiteChecker : COLORS.redChecker;
                const grad = ctx.createRadialGradient(x - 6, y - 6, 2, x, y, 22);
                grad.addColorStop(0, colors[0]);
                grad.addColorStop(1, colors[1]);
                
                if (isSelected) {
                    ctx.save();
                    ctx.shadowColor = COLORS.gold;
                    ctx.shadowBlur = 20;
                    ctx.strokeStyle = COLORS.gold;
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(x, y, 25, 0, Math.PI * 2); ctx.stroke();
                    ctx.restore();
                }

                ctx.beginPath();
                ctx.arc(x, y, 22, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 4;
                ctx.fill();
                ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1; ctx.stroke();
            };

            const draw = useCallback(() => {
                const ctx = canvasRef.current?.getContext('2d');
                if (!ctx) return;
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Tablero
                ctx.fillStyle = `rgba(15, 15, 15, ${boardOpacity})`;
                ctx.fillRect(50, 50, CANVAS_WIDTH - 100, CANVAS_HEIGHT - 100);
                
                // Puntos
                for (let i = 0; i < 24; i++) {
                    const { x, yBase, yTip, isTop } = getPointCoords(i);
                    ctx.fillStyle = (i % 2 === 0 ? COLORS.pointDark : COLORS.pointLight);
                    ctx.beginPath();
                    ctx.moveTo(x - 36, yBase); ctx.lineTo(x + 36, yBase); ctx.lineTo(x, yTip);
                    ctx.fill();

                    state.points[i].checkers.forEach((col, j) => {
                        const y = isTop ? 90 + (j * 44) : 710 - (j * 44);
                        drawChecker(ctx, x, y, col, selectedPoint === i && j === state.points[i].checkers.length - 1);
                    });
                }

                // Barra central
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(CANVAS_WIDTH/2 - 30, 50, 60, CANVAS_HEIGHT - 100);
                ['white', 'red'].forEach((col, idx) => {
                    for(let i=0; i<state.bar[col]; i++) {
                        const y = idx === 0 ? 250 - (i*40) : 550 + (i*40);
                        drawChecker(ctx, CANVAS_WIDTH/2, y, col, selectedPoint === 'bar' && col === state.turn);
                    }
                });

                // Dados
                state.dice.forEach((d, i) => {
                    const dx = CANVAS_WIDTH/2 + 150 + (i * 90), dy = CANVAS_HEIGHT/2 - 40;
                    ctx.fillStyle = '#fff'; ctx.shadowBlur = 15; ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.beginPath(); ctx.roundRect ? ctx.roundRect(dx, dy, 70, 70, 12) : ctx.fillRect(dx, dy, 70, 70);
                    ctx.fill(); ctx.shadowBlur = 0;
                    ctx.fillStyle = '#000'; ctx.font = '900 36px Inter'; ctx.textAlign = 'center';
                    ctx.fillText(d.toString(), dx + 35, dy + 48);
                });

                // Feedback visual de mano (si detecta)
                if (handPos) {
                    ctx.fillStyle = COLORS.gold;
                    ctx.beginPath(); ctx.arc(handPos.x, handPos.y, 10, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                }
            }, [state, selectedPoint, boardOpacity, handPos]);

            useEffect(() => {
                const h = requestAnimationFrame(draw);
                return () => cancelAnimationFrame(h);
            }, [draw]);

            // --- IA AVANZADA ---
            const runAI = () => {
                if (state.turn !== 'red' || state.winner) return;
                
                setTimeout(() => {
                    const ns = JSON.parse(JSON.stringify(state));
                    if (ns.dice.length === 0) {
                        const d1 = Math.floor(Math.random()*6)+1;
                        const d2 = Math.floor(Math.random()*6)+1;
                        ns.dice = [d1, d2];
                        ns.movesLeft = d1 === d2 ? [d1,d1,d1,d1] : [d1,d2];
                        setState(ns);
                        return;
                    }

                    // IA Básica: intenta mover siempre hacia adelante o comer si puede
                    let moved = false;
                    for (const die of ns.movesLeft) {
                        // Intentar salir de la barra primero
                        if (ns.bar.red > 0) {
                            const targetIdx = die - 1;
                            if (ns.points[targetIdx].checkers.length <= 1 || ns.points[targetIdx].checkers[0] === 'red') {
                                executeMove('bar', targetIdx, die, true);
                                moved = true; break;
                            }
                        } else {
                            // Buscar mejor movimiento
                            for (let i = 0; i < 24; i++) {
                                if (ns.points[i].checkers.includes('red')) {
                                    const target = i + die;
                                    if (target < 24 && (ns.points[target].checkers.length <= 1 || ns.points[target].checkers[0] === 'red')) {
                                        executeMove(i, target, die, true);
                                        moved = true; break;
                                    }
                                }
                            }
                        }
                        if (moved) break;
                    }

                    if (!moved) { // No hay jugadas posibles, pasa turno
                        ns.turn = 'white';
                        ns.dice = [];
                        ns.movesLeft = [];
                        setState(ns);
                    }
                }, 800);
            };

            useEffect(() => {
                if (view === 'PLAYING' && state.gameMode === 'AI' && state.turn === 'red') {
                    runAI();
                }
            }, [state.turn, state.dice, view]);

            // --- HAND TRACKING (AR) ---
            useEffect(() => {
                if (view !== 'PLAYING') return;

                const hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const landmarks = results.multiHandLandmarks[0];
                        const indexTip = landmarks[8]; // Punta del índice
                        // Mapeo invertido por el espejo del video
                        const x = (1 - indexTip.x) * CANVAS_WIDTH;
                        const y = indexTip.y * CANVAS_HEIGHT;
                        setHandPos({ x, y });
                        
                        // Si la mano está en una posición de clic (por ejemplo, bajando mucho en Z)
                        // Aquí podríamos disparar el clic AR. Por ahora dejamos visual.
                    } else {
                        setHandPos(null);
                    }
                });

                const camera = new Camera(videoRef.current, {
                    onFrame: async () => { await hands.send({ image: videoRef.current }); },
                    width: 640, height: 480
                });
                camera.start();
                handsRef.current = hands;

                return () => camera.stop();
            }, [view]);

            // --- INTERACCIÓN ---
            const handleBoardClick = (e) => {
                if (state.turn !== state.userColor && state.gameMode === 'ONLINE') return;
                if (state.turn === 'red' && state.gameMode === 'AI') return;

                const rect = canvasRef.current.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (CANVAS_WIDTH / rect.width);
                const y = (e.clientY - rect.top) * (CANVAS_HEIGHT / rect.height);

                if (Math.abs(x - CANVAS_WIDTH/2) < 40) {
                    if (state.bar[state.turn] > 0) setSelectedPoint('bar');
                    return;
                }

                let clicked = -1;
                for (let i = 0; i < 24; i++) {
                    const p = getPointCoords(i);
                    if (Math.abs(x - p.x) < 40 && ((p.isTop && y < 400) || (!p.isTop && y > 400))) {
                        clicked = i; break;
                    }
                }

                if (clicked !== -1) {
                    if (selectedPoint !== null) {
                        const die = state.movesLeft.find(d => {
                            const target = selectedPoint === 'bar' 
                                ? (state.turn === 'red' ? d - 1 : 24 - d)
                                : (state.turn === 'red' ? selectedPoint + d : selectedPoint - d);
                            return target === clicked;
                        });
                        if (die) executeMove(selectedPoint, clicked, die);
                        else if (state.points[clicked].checkers.includes(state.turn)) setSelectedPoint(clicked);
                    } else if (state.points[clicked].checkers.includes(state.turn)) {
                        setSelectedPoint(clicked);
                    }
                }
            };

            const executeMove = (from, to, die, isAI = false) => {
                setState(prev => {
                    const ns = JSON.parse(JSON.stringify(prev));
                    const p = ns.turn;
                    if (from === 'bar') ns.bar[p]--; else ns.points[from].checkers.pop();
                    
                    const dest = ns.points[to];
                    if (dest.checkers.length === 1 && dest.checkers[0] !== p) {
                        ns.bar[dest.checkers[0]]++;
                        dest.checkers = [p];
                    } else dest.checkers.push(p);

                    ns.movesLeft.splice(ns.movesLeft.indexOf(die), 1);
                    if (ns.movesLeft.length === 0) { 
                        ns.turn = ns.turn === 'white' ? 'red' : 'white'; 
                        ns.dice = []; 
                    }
                    
                    if (!isAI && ns.gameMode === 'ONLINE' && connRef.current?.open) {
                        connRef.current.send({ type: 'STATE', payload: ns });
                    }
                    return ns;
                });
                if (!isAI) setSelectedPoint(null);
            };

            // --- HANDSHAKE P2P ---
            const initP2P = (rid, isHost) => {
                const peer = new Peer(`bg-v4-${rid}-${isHost ? 'host' : 'guest'}`);
                peerRef.current = peer;
                peer.on('open', () => {
                    if (!isHost) {
                        const c = peer.connect(`bg-v4-${rid}-host`);
                        connRef.current = c;
                        c.on('open', () => { setView('PLAYING'); c.send({ type: 'REQ' }); });
                        c.on('data', d => d.type === 'STATE' && setState(s => ({...s, ...d.payload, userColor: 'red'})));
                    } else {
                        peer.on('connection', c => {
                            connRef.current = c;
                            c.on('data', d => {
                                if (d.type === 'REQ') c.send({ type: 'STATE', payload: state });
                                if (d.type === 'STATE') setState(s => ({...s, ...d.payload}));
                            });
                            setView('PLAYING');
                        });
                    }
                });
            };

            return React.createElement('div', { className: 'w-full h-full relative bg-black' }, [
                React.createElement('video', { key: 'v', ref: videoRef, autoPlay: true, playsInline: true, muted: true, style: { opacity: camOpacity } }),
                React.createElement('canvas', { key: 'c', ref: canvasRef, width: CANVAS_WIDTH, height: CANVAS_HEIGHT, onClick: handleBoardClick }),
                
                React.createElement('div', { key: 'ui', className: 'ui-layer' }, [
                    
                    // HEADER (Estilo Foto)
                    view === 'PLAYING' && React.createElement('header', { className: 'h-24 flex items-center justify-between px-10' }, [
                        React.createElement('button', { onClick: () => setIsMenuOpen(true), className: 'w-12 h-12 flex flex-col justify-center items-center gap-1.5' }, [
                            React.createElement('div', { className: 'w-8 h-1 bg-white rounded-full' }),
                            React.createElement('div', { className: 'w-8 h-1 bg-white rounded-full' }),
                            React.createElement('div', { className: 'w-8 h-1 bg-white rounded-full' }),
                        ]),
                        React.createElement('div', { className: `px-12 py-3 rounded-full font-black text-sm uppercase tracking-widest ${state.turn === state.userColor ? 'bg-amber-500 text-black active-glow' : 'bg-white/10 text-white/40'}` }, 
                            state.turn === state.userColor ? 'TU TURNO' : 'TURNO RIVAL'
                        ),
                        React.createElement('button', { 
                            onClick: () => {
                                const d1 = Math.floor(Math.random()*6)+1, d2 = Math.floor(Math.random()*6)+1;
                                const ns = {...state, dice: [d1,d2], movesLeft: d1===d2 ? [d1,d1,d1,d1] : [d1,d2]};
                                if (connRef.current?.open) connRef.current.send({ type: 'STATE', payload: ns });
                                setState(ns);
                            },
                            disabled: state.movesLeft.length > 0 || (state.gameMode === 'ONLINE' && state.turn !== state.userColor),
                            className: 'px-12 py-3 bg-white text-black font-black rounded-full text-sm uppercase shadow-2xl disabled:opacity-20'
                        }, 'LANZAR'),
                    ]),

                    // MENU LATERAL (Foto Referencia)
                    React.createElement('div', { className: `side-menu ${isMenuOpen ? 'open' : ''}` }, [
                        React.createElement('div', { className: 'flex justify-between items-center mb-16' }, [
                            React.createElement('h2', { className: 'text-4xl font-black italic tracking-tighter' }, 'OPCIONES'),
                            React.createElement('button', { onClick: () => setIsMenuOpen(false), className: 'w-10 h-10 bg-red-600 rounded-xl flex items-center justify-center font-bold text-xl' }, '✕')
                        ]),
                        React.createElement('div', { className: 'space-y-12 flex-1' }, [
                            React.createElement('div', { className: 'space-y-4' }, [
                                React.createElement('div', { className: 'flex justify-between text-[10px] font-black uppercase text-white/40 tracking-widest' }, ['Tablero', Math.round(boardOpacity*100)+'%']),
                                React.createElement('input', { type: 'range', min: 0, max: 1, step: 0.05, value: boardOpacity, onChange: e => setBoardOpacity(parseFloat(e.target.value)) })
                            ]),
                            React.createElement('div', { className: 'space-y-4' }, [
                                React.createElement('div', { className: 'flex justify-between text-[10px] font-black uppercase text-white/40 tracking-widest' }, ['Cámara', Math.round(camOpacity*100)+'%']),
                                React.createElement('input', { type: 'range', min: 0, max: 1, step: 0.05, value: camOpacity, onChange: e => setCamOpacity(parseFloat(e.target.value)) })
                            ]),
                            React.createElement('button', { className: 'btn-menu' }, 'ROTAR TABLERO'),
                            React.createElement('button', { onClick: () => { setState(getInitialState()); setIsMenuOpen(false); }, className: 'btn-menu accent' }, 'REINICIAR'),
                        ]),
                        React.createElement('button', { onClick: () => window.location.reload(), className: 'btn-menu' }, 'SALIR')
                    ]),

                    // HOME MENU (Foto 1)
                    view === 'HOME' && React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center space-y-8 bg-black z-50 p-6' }, [
                        React.createElement('h1', { className: 'title-main mb-20' }, 'B-GAMMON'),
                        React.createElement('button', { onClick: () => { setState(s => ({...s, gameMode: 'AI'})); setView('PLAYING'); }, className: 'w-96 py-8 bg-white text-black font-black rounded-3xl uppercase text-xl shadow-2xl' }, 'VS MÁQUINA'),
                        React.createElement('button', { onClick: () => setView('LOBBY'), className: 'w-96 py-8 bg-zinc-800 text-white font-black rounded-3xl uppercase text-xl' }, 'MULTIJUGADOR'),
                        React.createElement('button', { onClick: () => { setState(getInitialState()); setView('PLAYING'); }, className: 'w-96 py-6 bg-zinc-900 text-white/30 font-black rounded-3xl uppercase text-sm' }, 'LOCAL (2 PLAYERS)'),
                    ]),

                    view === 'LOBBY' && React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center bg-black z-50' }, [
                        React.createElement('button', { onClick: () => {
                            const rid = Math.random().toString(36).substring(2, 7).toUpperCase();
                            setState(s => ({...s, roomID: rid, gameMode: 'ONLINE'}));
                            initP2P(rid, true); setView('INVITE');
                        }, className: 'px-24 py-8 bg-amber-500 text-black font-black rounded-[40px] uppercase text-2xl shadow-glow' }, 'CREAR SALA'),
                        React.createElement('button', { onClick: () => setView('HOME'), className: 'mt-12 text-white/30 font-black tracking-widest' }, 'VOLVER')
                    ]),

                    view === 'INVITE' && React.createElement('div', { className: 'flex-1 flex flex-col items-center justify-center p-8 bg-black/95 z-50' }, [
                        React.createElement('h2', { className: 'text-4xl font-black mb-12 italic uppercase' }, 'SALA: ' + state.roomID),
                        React.createElement('button', { onClick: () => { 
                            navigator.clipboard.writeText(window.location.origin + '/?room=' + state.roomID);
                            alert("Link Copiado!");
                        }, className: 'px-16 py-6 bg-white text-black font-black rounded-2xl uppercase shadow-glow' }, 'COPIAR ENLACE'),
                        React.createElement('p', { className: 'mt-12 text-white/40 animate-pulse font-bold tracking-widest' }, 'ESPERANDO OPONENTE...')
                    ])
                ])
            ]);
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>
